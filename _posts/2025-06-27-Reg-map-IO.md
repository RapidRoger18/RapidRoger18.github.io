---
layout: post
title:  "BeagleV-Fire"
author: Atharva
categories: [ GSOC ]
tags: [Updates]
image: ../assets/images/BeagleV-Fire.png
description: "A little introduction about BeagleV-Fire board which will be used during my GSOC project"
featured: true
hidden: false
---
As mentioned in the last post I had completed testing Memory mapped I/O and discovered some big red flags. While trying to figure out these issues I had an idea, to map the I/O on registers. Now these wouldn't be traditional register mapped I/O about which We'll talk later on, but these would be memory mapped registers while each bit of the register represents a I/O pin.

Thus we could have a Input register a Output register and a output enable register which would fit easily with the already present CAPE module on BeagleV-Fire. During the time of planning this approach I had lots of discussion with my mentors as this wasn't exactly fastes approach but other known approaches would include adding custom instructions for I/O operations, thus modifying the compiler for the same which would complicate the project and would go out of scope for a GSOC project.

With this said I mapped the IO to registers through Verilog in my IO Controller and added the addresses as wrappers to the main CPU. This would give us following advantages:
- All I/Os can be accessed through a single operation cycle.
- Latency would decrease significatly since the I/O pins will be coupled.

The memory accessed through the C code would remain the same:
```C:
#define GPIO_INPUT   (*(volatile uint32t *) 0x03000000)
#define GPIO_OE      (*(volatile uint32t *) 0x03000004)
#define GPIO_OUTPUT  (*(volatile uint32t *) 0x03000008)
```
